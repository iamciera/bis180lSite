<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Ian Korf Unit 1 - Just Enough Unix for Bioinformatics</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Genomics BIS180L - UC Davis Spring 2014</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Ian Korf Unit 1 - Just Enough Unix for Bioinformatics</h2>
<p class="meta">03 Apr 2014</p>

<div class="post">
<p>This is meant to be a very quick introduction to the Unix operating
system for the BIS180L bioinformatics laboratory class at UC Davis. The
examples below assume you are using Ubuntu Linux 13.10, other versions
and distributions will probably be fine. Why does the title of this
document mention Unix when the distribution is Linux? Is there a
difference between Unix and Linux? Practically, no; philosophically,
sort-of; politically, yes. No time to discuss. Onward.</p>

<h2>Author, Version, and Other Front-matter</h2>

<p>This document was authored by Ian Korf. It is in the  Public Domain. No
rights reserved. It is for entertainment purposes only, so if you hurt
yourself, don&#39;t blame me. The text was prepared in Markdown format (John
Gruber) using BareBones TextWrangler. The PDF version was formatted with
Marked (by Brett Terpstra) using the GitHub stylesheet. Thanks clever
and kind developers for making my life easier.</p>

<h2>Terminal, Command Line, and Shell</h2>

<p>Your interface to Unix will be through a <strong>shell</strong> program using the
<strong>command line interface</strong> within a <strong>terminal</strong> application. There are
several types of shells and terminals, but the details of these are
unnecessary for us. The command line is where you type instructions for
what you want the computer to do. Some of these statements are &quot;do this
now&quot; while others are &quot;let&#39;s get ready to do this.&quot; It may seem silly in
this high-tech age to type your commands when you could simply point and
click or maybe even use voice activation or gesturing. It is easier to
automate typing though. So when it comes time to work with thousands of
files, it will be much easier through a command line interface.</p>

<h3>Terminal Basics</h3>

<p>Launch the terminal application (the name of this will differ from one
operating system to another and even within a particular OS you will
have several options). Run the <code>date</code> command by typing in the terminal
and ending with the <strong>return</strong> key.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">date
</code></pre></div>
<p>Congratulations, you just made your first Unix statement. You type words
on the command line (in this case just one) and then hit return to
execute the command. <code>date</code> is but one of hundreds of Unix commands you
have at your fingertips (literally). Like most Unix commands, <code>date</code>
does more than simply output the current date in the format you just
witnessed. You can choose any number of formats and even set the
internal clock to a specific time. Let&#39;s explore this a tiny bit.
Commands can take <strong>arguments</strong>. Let&#39;s tell the <code>date</code> program that we
want the date to be formatted a year-month-day and with
hours-minutes-seconds also. The syntax below will seem arcane, but the
various abbreviations should be obvious.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">date &quot;+%Y-%m-%d %H:%M:%S&quot;
</code></pre></div>
<h3>Manual Pages</h3>

<p>If you want to learn more information about what <code>date</code> can do, you can
either look online or use the Unix built-in manual pages. For a quick
refresher on a command, the manual pages are often easiest. But if you
have no idea what the command does, than you might want to look for
assistance online. To read the manual pages for <code>date</code> you use the <code>man</code>
command.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">man date
</code></pre></div>
<p>You can page through this with the space bar and exit with <code>q</code>. In the
above statement, <code>man</code> was the command and <code>date</code> was the argument. The
program that let you page through the documentation was another Unix
command that you didn&#39;t intentionally invoke, it just happens
automatically when you execute the <code>man</code> command.</p>

<h3>Injury Prevention</h3>

<p>Typing is bad for your health. Seriously, if you type all day, you will
end up with an repetitive stress injury. Don&#39;t type for hours at a time.
Make sure you schedule breaks. Unix has several ways to save your
fingers. Let&#39;s go back run the <code>date</code> program again. Instead of typing
it in, use the <strong>up arrow</strong> on your keyboard to go backwards through
your command history. If you scroll back too far, you can use the <strong>down
arrow</strong> to move forward through your history (but not into the future,
Unix isn&#39;t that smart).</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">date &quot;+%Y-%m-%d %H:%M:%S&quot;
</code></pre></div>
<p>You can use the <strong>left arrow</strong> and <strong>right arrow</strong> to edit the text on
the command line.</p>

<p>To see your entire history of commands in this session, use the
<code>history</code> command.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">history
</code></pre></div>
<p>If you want to repeat a particular command line, you can select a
specific line of your history. For example, to re-run command line #7,
you type the following:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">!7
</code></pre></div>
<p>Probably the most important finger saver in Unix is <strong>tab completion</strong>.
When you hit the tab key, it completes the rest of the word for you. For
example, instead of typing out <code>history</code> you can instead type <code>his</code>
followed by the tab key, the rest of the word will be completed. If you
use something less specific, can hit the tab key a second time and Unix
will show you the various legal words. Try typing <code>h</code> and then the tab
key twice. Those are all the commands that begin with the letter h. We
will use tab completion constantly. Not only does it save you key
presses and time, it also ensures that your spelling is correct. Try
misspelling the <code>history</code> command to observe the error it reports.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">historie
</code></pre></div>
<h3>Variables</h3>

<p>The shell defines various variables which are called <strong>shell variables</strong>
or <strong>environment variables</strong>. For example, the <code>USER</code> variable contains
your user name. You can examine the contents of a variable with the
<code>printenv</code> command.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">printenv USER
</code></pre></div>
<p>We won&#39;t use variables much, but it&#39;s important to know they exist
because some programs use them for configuration. If you want to see all
your environment variables, you can use the <code>printenv</code> command without
any arguments. Don&#39;t worry if this is very confusing because we don&#39;t
care about it at this point.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">printenv
</code></pre></div>
<h2>Files &amp; Directories</h2>

<p>Unix is mostly a text environment. You will be reading and writing a lot
of text files. To do this you will use a text editor. There are many,
many text editors, and some people are insanely passionate about one or
the other. We don&#39;t have time for that. We&#39;ll use two: <strong>nano</strong>, which
works from your command line interface, and also <strong>gedit</strong> that works
like a word processor.</p>

<p>In Unix, pretty much everything is a file. You need to be able to
create, edit, and delete files and directories to do anything. You can
do some of these things from the graphical desktop interface, but resist
this. The more comfortable you are using the command line for
everything, the better off you will be.</p>

<p>The <strong>file system</strong> is where your files are stored. This could be a hard
disk or other medium, and there could be one or more. To see how much
free space you have on your file system, use the <code>df</code> (disk free)
command with the <code>-h</code> option to make it more human-readable (try it both
ways).</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">df
df -h
</code></pre></div>
<p>Another useful command is <code>du -h</code> (disk usage) which shows how much
space each of your files and directories uses.</p>

<h3>Creating and Viewing Files</h3>

<p>(For the this exercise and others that follow, it may be useful to have
your graphical desktop displaying the contents of your home directory.
That way you can see that typing and clicking ar related.)</p>

<p>There are a number of ways to create a file. The <code>touch</code> command will
create a file or change its modification time (Unix records when the
last time a file was edited) if it already exists.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">touch foo
</code></pre></div>
<p>The file <code>foo</code> doesn&#39;t contain anything at all. It is completely empty.
Now lets create a file with some content in it.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cat &gt; bar
</code></pre></div>
<p>After you hit return, you will notice that you do not return to a
command line prompt. Keep typing. Write a bunch of nonsense lines. Keep
going. Write poetry if you must. Everything you&#39;re entering at the
keyboard is now going into the file called <code>bar</code>. To end the file, you
need to send the end-of-file character, which is control-D. This
character is at the end of every text file. Hit the control key and then
the letter d. Another way of saying this is hit the ^D character. Note
that you don&#39;t type the ^ or the capital D. It&#39;s just the way we
communicate in writing that one should type the control key and then the
d key.</p>

<p>To see the contents of the file, you can also use the <code>cat</code> command.
This dumps the entirety of the file into your terminal.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cat bar
</code></pre></div>
<p>This isn&#39;t very useful for viewing unless you&#39;re a speed reader. You can
inspect the first 10 lines of a file with the <code>head</code> command.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">head bar
</code></pre></div>
<p>Similarly, you can inspect the last 10 lines with <code>tail</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tail bar
</code></pre></div>
<p>Both of these commands have command line options so that you can see a
different number of lines. For example, to see just the first line you
would do the following:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">head -1 bar
</code></pre></div>
<p>A more useful way to look at files is with a <strong>pager</strong>. The <code>more</code> and
<code>less</code> commands let you see a file one terminal page at a time. This is
what you used before when viewing the manual page for the <code>date</code>
command. Use the spacebar to advance the page and q to quit. <code>more</code> and
<code>less</code> do more or less the same thing, but oddly enough <code>less</code> does more
than <code>more</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">less bar
</code></pre></div>
<h3>Editing Files</h3>

<p>You can edit files with nano or gedit. Let&#39;s stay in the terminal and
use nano for now.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">nano bar
</code></pre></div>
<p>This brings up a terminal-based editor. Now you can change the random
text you just wrote. Use the arrow keys to move the cursor around. Add
some text by typing. Remove some text with the delete key. At the
bottom, you can see a menu that uses control keys. To save the file you
hit the ^O key (control and then the letter o). You will then be
prompted for the file name, at which point you can overwrite the current
file (bar) or make a new file with a different name. To exit nano, use
^X. Note, you don&#39;t need to give nano an argument when you start it up.</p>

<p>Open up a new terminal. Create a new file called <code>unix_notes.txt</code>
(either by touching it first or saving an empty nano file). Use this to
record the various things you&#39;ve learned today. You might want to go
back to this later. </p>

<p>Unix file names often have the following properties:</p>

<ul>
<li>all lowercase letters</li>
<li>no spaces in the name (use underscores or dashes instead)</li>
<li>an extension such as .txt</li>
</ul>

<h3>Navigating Directories</h3>

<p>Whenever you are using a terminal, your focus is a particular directory.
The files you just created above were in a specific directory. To
determine what directory you are currently in, use the <code>pwd</code> command
(print working directory).</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">pwd
</code></pre></div>
<p>This will tell you your location is <code>/home/bios180student</code> (or maybe
 not if you&#39;re reading this outside the context of the class or if the
 documentation is out of date - it doesn&#39;t matter, this is your home
 directory). The current directory is also known by the single letter <code>.</code>
 (that is not the end of the sentence, it&#39;s the period character). If
 you want to know what files are in your current working directory, use
 the following command:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls .
</code></pre></div>
<p><code>ls</code> will list your current directory if you don&#39;t give it an argument,
so an equivalent statement is simply:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls
</code></pre></div>
<p>Notice that <code>ls</code> reports the files and directories in your current
working directory. It&#39;s a little difficult to figure out which ones are
directories right now. So let&#39;s add a command line option to the <code>ls</code>
command.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls -F
</code></pre></div>
<p>This command adds a character to the end of the file names to indicate
what kind of files they are. A forward slash character indicates that
the file is a directory. These directories inside your working directory
are sub-directories. They are <strong>below</strong> your current location. There are
also directories <strong>above</strong> you. There is at most one directory
immediately above you. We call this your parent directory, which in Unix
is called <code>..</code> (again, not the end of this sentence, but rather two
period characters together). You can list your parent directory as
follows:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls ..
</code></pre></div>
<p>The <code>ls</code> command has a lot of options. Try reading the <code>man</code> pages and
trying some of them out. Now is a good time to experiment with a few
command line options. Note that you can specify them in any order and
collapse them if they don&#39;t take arguments (some options have
arguments). Don&#39;t forget to log your learning in your other terminal.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">man ls
ls -a
ls -l
ls -l -a
ls -a -l
ls -la
ls -al
</code></pre></div>
<p>There are two ways to specify a directory: <strong>relative</strong> path and
<strong>absolute</strong> path. Everything so far has been the relative path. The
command <code>ls ..</code> listed the directory above the current directory. The
command <code>nano bar</code> edited the file <code>bar</code> in the current directory. What
if you want to list some directory somewhere else or edit a file
somewhere else? To specify the absolute path, you precede the path with
a forward slash. For example, to list the absolute root of the Unix file
system, you would type the following:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls /
</code></pre></div>
<p>To list the contents of /usr/bin you would do the following</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls /usr/bin
</code></pre></div>
<p>This works exactly the same from whatever your current working directory
is. But this is not true of the relative path.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls ..
</code></pre></div>
<p>To change your working directory, you use the <code>cd</code> command. Try changing to the root directory</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cd /
pwd
ls
</code></pre></div>
<p>Now return to your home directory by executing <code>cd</code> without any arguments.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cd
pwd
ls
</code></pre></div>
<p>Now go back to the root directory and create a file in your home
directory. There are a couple short-cut ways to do this. The <code>HOME</code>
variable contains the location of your home directory. But ~ (tilde) is
another shortcut for the same thing and requires less typing. Note that
to get the contents of the <code>HOME</code> variable, we have to precede it with a
<code>$</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cd /
touch $HOME/file1
touch ~/file2
</code></pre></div>
<p>Now create a couple more files but using absolute and relative paths
rather than short-cuts.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">touch /home/bios180student/file3
cd ~/Documents
pwd
ls
touch ../file4
</code></pre></div>
<h3>Moving and Renaming Files</h3>

<p>Your home directory is starting to fill up with a bunch of crap. Let&#39;s
organize that stuff. First off, let&#39;s create a new directory for &#39;Stuff&#39;
using the <code>mkdir</code> command.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cd
mkdir Stuff
</code></pre></div>
<p>Notice that the directory starts with a capital letter. This isn&#39;t
required, but it&#39;s a good practice. Now let&#39;s move some files into that new directory with the <code>mv</code> command.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">mv foo Stuff
</code></pre></div>
<p>If there are 2 arguments and the 2nd argument is not a directory, the
<code>mv</code> command will rename the file. Yes, it&#39;s weird that <code>mv</code> both moves
and renames files. That&#39;s Unix.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">mv bar barf
mv barf Stuff
ls
</code></pre></div>
<p>You can move more than one file at a time. The last argument is where
you want to move it to.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">mv file1 file2 file3 file4 Stuff
ls
ls Stuff
</code></pre></div>
<h3>Copying and Aliasing</h3>

<p>The <code>cp</code> command copies files. Let&#39;s say you wanted a copy of barf in
your home directory.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cp Stuff/barf .
ls
ls Stuff
</code></pre></div>
<p>Now you have 2 copies of barf. If you edit one file, it will be
different from the other. Try that with nano.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">nano barf
# do some editing and save it
cat barf
cat Stuff/barf
</code></pre></div>
<p>When you do the copying, you don&#39;t have to keep the same name.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cp Stuff/barf ./bark
ls
</code></pre></div>
<p>Things are getting a little messy, so let&#39;s put these files back into
the Stuff directory. But let&#39;s do it using the * wildcard, which is
somewhat magical because it fills in missing letters of arguments. Every
file that starts with <code>ba</code> will now be moved to Stuff.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">mv ba* Stuff
ls
</code></pre></div>
<p>That was just two files, but I think you can imagine the power of moving
100 files with a single command.</p>

<p>An alias is another name for a file. These are often useful to organize
your files and directories. Let&#39;s try it using the <code>ln -s</code> command (we
always use the <code>-s</code> option with <code>ln</code>).</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ln -s Stuff/foo ./foof
nano foof
# do some editing
cat foof
cat Stuff/foo
</code></pre></div>
<h3>Deleting Files</h3>

<p>You delete files with the <code>rm</code> command. Be careful, because once gone,
they are gone forever.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls Stuff
rm Stuff/file1
ls Stuff
rm foof
</code></pre></div>
<p>You didn&#39;t type those file names completely, right? You used tab
completion, right?</p>

<p>You can delete multiple files at once too and even whole directories.
But you&#39;re better off using the graphical interface to delete files.
Deleting files is not something we wish you to automate.</p>

<h3>Working with Text Files</h3>

<p>There are 2 kinds of files: text and binary. A text file looks like the
file you&#39;re reading. There are familiar letters, words, and punctuation
(include spaces between words). Binary files don&#39;t look like this.
Instead, they look like a bunch of random letters, some of which don&#39;t
even display properly on your screen. Let&#39;s look at one.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cat /bin/ls
</code></pre></div>
<p>Yuck. Most of the programs you run on a computer are binary files.
Generally speaking, binary files are for machine consumption and text
files are for human consumption (or readability). Text files come in 3
common flavors. Unix text files have a newline character at the end of
each line. Mac text files generally also use newline characters, but
carriage returns were used in the past and are still sometimes used.
Windows files end in carriage returns plus newlines (they have 2
characters to denote end of line). These differences in line endings can
cause problems when interchanging files among computers. For this
reason, avoid interchanging files between you Linux, Mac, and Windows
computers. <strong>One of the stupidest things you can do is to put sequence
data into Microsoft Word or Excel (or similar software) and then attempt
to use it in Unix.</strong></p>

<p>Bioinformatics often deals with large text files. These can contain
whole genomes, massive RNA-seq experiments, or thousands of spectra. You
need to appreciate the size of these files so that you don&#39;t do stupid
stuff with them, like email them to a colleague. Let&#39;s look at the
Arabidopsis thaliana genome. First, let&#39;s see how big it is. We&#39;ll use
the <code>ls</code> with the <code>-h</code> and <code>-l</code> options so that we can see the size of
the file. Please use tab completion when typing the following.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls -lh /data/C.elegans
</code></pre></div>
<p>You should see something that looks similar to this:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">-rw------- 1 ian  staff    29M Nov 26 14:41 c_elegans.PRJNA13758.WS240.genomic.fa.gz
-rw------- 1 ian  staff   5.9M Oct  9 21:06 c_elegans.PRJNA13758.WS240.protein.fa.gz
</code></pre></div>
<p>There are two files, one contains genomic sequence, the other contains
protein. The genome is 29 megabytes. That&#39;s not a very big file, but
it&#39;s too big to email. A knee-jerk reaction might be to open this in
your text editor. That&#39;s a bad idea for several reasons: (1) You
shouldn&#39;t edit data files. (2) It takes way a lot more memory to edit a
file than view its contents. (3) The file is binary. Let&#39;s do it anyway.
Use tab completion to do the following.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">nano /data/C.elegans/c_elegans.PRJNA13758.WS240.genomic.fa.gz
</code></pre></div>
<p>The file is binary, so it looks like gibberish. We need to uncompress it
to see its contents. The file name is also hopelessly long. Let&#39;s
organize ourselves a little. First, let&#39;s create a directory where we
can collect our work.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">mkdir ~/Project0
cd ~/Project0
</code></pre></div>
<p>The path to the genome file is long. We can simplify it with an alias.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ln -s /data/C.elegans/c_elegans.PRJNA13758.WS240.genomic.fa.gz ./genome.gz
ls -lF
</code></pre></div>
<p>Note what <code>ls -lF</code> shows you. The <code>@</code> symbol trailing the file name
shows you that the file is an alias. The arrow shows you what the alias
points to.</p>

<p>Now let&#39;s start uncompressing it. The <code>gunzip</code> command uncompresses
files. If we want to stream the file to the terminal in a way similar to
<code>cat</code> we use <code>gunzip -c</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gunzip -c genome.gz
</code></pre></div>
<p>When you get sick of watching the text scroll by, you can interrupt it
with a ^C (control-c). ^C is a good way to interrupt a runaway process.
But sometimes it doesn&#39;t work and you may have better luck with ^Z,
which sleeps the process (yes, just like the Borg). More on that later.</p>

<p>Sometimes we want to look at the first few lines of a file without
committing ourselves to the whole file. <code>head</code> is great for that.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">head genome.gz
</code></pre></div>
<p>Rats, it&#39;s still binary. What would be great is if we could uncompress
the file and view the contents with <code>head</code>. One of the awesome powers of
Unix is that you can pipeline the output of one program to the input of
another with the pipe <code>|</code> token. This might look like a capital I or
lowercase l, but it&#39;s not, it&#39;s its own strange beast located somewhere
where you right pinkie can access it.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gunzip -c genome.gz | head
</code></pre></div>
<p>Success. The first line of the file is a FASTA header and this is
followed by a bunch of sequence lines. If you don&#39;t know what the FASTA
format is, now is a good time to read about the FASTA format online.</p>

<p>FASTA files sometimes contain multiple sequences. As this file
represents the C. elegans genome, we expect 6 chromosomes. Let&#39;s look
for those in the file.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gunzip -c genome.gz | less
</code></pre></div>
<p>Now we can page through the file looking for lines that start with <code>&gt;</code>.
As you page through the file, note how long the chromosome is. It will
take you over 12,000 more spacebar presses to get to the next chromosome
(assuming your terminal is still 24 lines). Remember, this is a small
genome. One of the features of <code>less</code> is that it allows you to search
for simple patterns. Hit the forward-slash key <code>/</code> to bring up the
search prompt at the bottom of the terminal. Now hit the <code>&gt;</code> key and
press return. <code>less</code> will find the next <code>&gt;</code> symbol in the file. Keep
hitting the <code>/</code> key and return. <code>less</code> remembers the last pattern.</p>

<p>If you need to find patterns in files, the Unix <code>grep</code> command is often
the first tool people turn to.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gunzip -c genome.gz | grep &quot;&gt;&quot;
</code></pre></div>
<p>Now let&#39;s save that output to a file. You can redirect the output of a
program to a file with the <code>&gt;</code> token.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gunzip -c genome.gz | grep &quot;&gt;&quot; &gt; chromosomes.txt
cat chromosomes.txt
</code></pre></div>
<p>You will be creating a lot of files in this course. Sometimes they will
be large. Use <code>gzip</code> and <code>gunzip</code> as needed. <code>gzip</code> usually makes a file
between 50% and 25% its size, so it&#39;s a great way to save space,
especially when you start to work with large -omic data files.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gzip chromosomes.txt
ls -l
gunzip chromosomes.txt
ls -l
</code></pre></div>
<p>Note that <code>gzip</code> automatically adds and removes the <code>.gz</code> file extension
appropriately.</p>

<p>In Unix, when people send you multiple files, they generally send them
as a <strong>tar ball</strong>. The <code>tar</code> command creates archives, which are single
files that contain multiple files. Let&#39;s create a bunch of files in this
directory.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">touch file1 file2 file3 file4 file5
</code></pre></div>
<p>Now let&#39;s <code>cd</code> up a directory and have a look around.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cd ..
ls
ls Project0
</code></pre></div>
<p>To create an archive of Project0, we need to tell the <code>tar</code> command that
we want to create the archive with the <code>-c</code> option and tell it the name
of the file with the <code>-f</code> option.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tar -c -f project0.tar Project0
</code></pre></div>
<p>Unix options generally go before the arguments on the command line.
That&#39;s why <code>-f project0.tar</code> goes before <code>Project0</code>. You can collapse
single letter options if you&#39;re lazy. So the following command is the
same thing.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tar -cf project0.tar Project0
ls
</code></pre></div>
<p>To save space on your file system, you should compress your tar-balls.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gzip project0.tar
ls
</code></pre></div>
<p>The <code>tar</code> command will do this automatically with the <code>-z</code> option. So
when you want to create a tar-ball, the one-liner is as follows:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tar -czf project0.tar.gz Project0
</code></pre></div>
<p>To decompress a tar-ball, you swap the <code>-c</code> option for the <code>-x</code> option.
Before we do that, let&#39;s create a new directory and inflate the tar-ball
in there so that we make a copy and don&#39;t overwrite our original
directory.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">mkdir Stuff
mv project0.tar.gz Stuff
cd Stuff
tar -xzf project0.tar.gz
ls
ls Project0
</code></pre></div>
<h3>Using File Permissions</h3>

<p>A file can have 3 kinds of permissions: read, write, and execute. These
are abbreviated as <code>rwx</code> when you do a <code>ls -l</code>. Read and write are
obvious, but execute is a little weird. Programs and directories need
executable permission to access them. Important data files, like the
genome of C. elegans, should not be edited. To ensure that, they should
have read only permission. Every file has permissions for the user,
group, and public. So a file can be readable by you and inaccessible to
the public. Let&#39;s look at one of the files we just created.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ls -lF chromosomes.txt
</code></pre></div>
<p>This will produce something like the following, which shows the
permissions, owner (ian), group (staff), size (29 bytes), date, and file
name. </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">-rw-r--r--  1 ian  staff    29B Mar 26 11:11 chromosomes.txt
</code></pre></div>
<p>Let&#39;s first turn on all permissions for everyone.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">chomd 777 chromosomes.txt
</code></pre></div>
<p>The explanation of what this does will have to wait for a bit. The file now has the following properties.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">-rwxrwxrwx  1 ian  staff    29B Mar 26 11:11 chromosomes.txt*
</code></pre></div>
<p>The first character is a hyphen. This means the file is an ordinary
file. If the file was a directory, the letter would be a d. If it was an
alias, the letter would be an l. The 3 rwx symbols that follow are the
read, write, and execute permissions for user, group, and public. So
everyone has permission to read, write, and execute this file. If you
copy files from a USB flash drive, it will typically have all these
permissions because the file system on most flash drives is not
Unix-based. Having all permissions on is generally not a good idea. Most
files fit into one of a few categories.</p>

<p>| Category   | Code         | Oct | Meaning 
|:-----------|:-------------|:----|-----------------------------------------
| raw data   | <code>-r--r--r--</code> | 444 | anyone can read, nobody can write
| private    | <code>-rw-------</code> | 600 | I can read/write, others nothing
| shared     | <code>-rw-r--r--</code> | 644 | I can read/write, group/public can read
| shared     | <code>-rw-rw-r--</code> | 664 | We can read/write, public can read</p>

<p>You can change the permissions of a file with the <code>chmod</code> command. There
are two different syntaxes. The more human readable one looks like this.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">chmod u-x chromosomes.txt
</code></pre></div>
<p>This command says &quot;change the user (u) to remove (-) the execute (x)
permission from file chromosmes.txt&quot;. You add permissions with +.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">chmod u+x chromosomes.txt
</code></pre></div>
<p>The octal format is convenient because it changes all of the permissions
at once, but can be confusing for people who don&#39;t think in octal. 4 is
the read permission. 2 is the write permission. 1 is the execute
permission. Each rwx corresponds to one octal number from 0 to 7. So
<code>chmod 777</code> turns on all permissions for all types of people and
<code>chmod 000</code> turns them all off. I generally use only two permissions:
444 and 644. That is, everything is readable, but somethings only I can
write.</p>

<h2>Processes</h2>

<p>One of the most important programs in Unix is <code>top</code> because it lets us
monitor the health of our computer. Open up a new terminal and start the
program.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">top
</code></pre></div>
<p>On Unix systems, <code>top</code> is the equivalent of the the Task Manger in
Windows and the Activity Monitor in Mac OS. Once you start running
bioinformatics software on your computer, you can monitor what is
happening using <code>top</code>. </p>

<h3>Viewing Processes</h3>

<p>Let&#39;s go back to an previous command and watch it with <code>top</code>. Notice
that it doesn&#39;t use 100% of the CPU.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">gunzip -c genome.gz
</code></pre></div>
<p>Let&#39;s do that one more time, and this time we will use the <code>time</code>
command to determine the elapsed and CPU time.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">time gunzip -c genome.gz
</code></pre></div>
<p>On my computer, I get the following stats</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">real    0m6.930s
user    0m0.483s
sys     0m0.859s
</code></pre></div>
<p>It took about 7 seconds to stream the contents to my terminal. The CPU
time is the sum of the user and sys time. Why did it take so much more
real time than CPU time? Because it takes some time to display to the
terminal, during which the CPU isn&#39;t very busy. Let&#39;s try the same task
and send the output to a file.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">time gunzip -c genome.gz &gt; foo
</code></pre></div>
<p>Big difference!</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">real    0m0.413s
user    0m0.357s
sys     0m0.056s
</code></pre></div>
<p>Sometimes we don&#39;t even need to see the output. In this case, we can
redirect the output to <code>/dev/null</code> which is Unix&#39;s black hole (not even
electrons escape).</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">time gunzip -c genome.gz &gt; /dev/null
</code></pre></div>
<p>Faster still because we don&#39;t have to write to the file system.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">real    0m0.356s
user    0m0.348s
sys     0m0.009s
</code></pre></div>
<p>Note that the CPU time is slightly greater than the real time. How can
something take less wall clock time than CPU time? Are we violating the
laws of physics? No, your computer has more than one core and can split
up tasks on various cores. For programs that can utilize multiple cores,
the real time may be much less than the CPU time.</p>

<h3>Managing Processes</h3>

<p>Sometimes you will start a program and decide you want to stop it
permanently or temporarily. Run the following command and then watch
what happens in <code>top</code>. You may find it useful to copy-paste this command
from the document to your terminal to make sure you don&#39;t introduce
spelling errors.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">perl -e &#39;while(1){print $i++, chr(10)}&#39;
</code></pre></div>
<p>This command is an endless loop in the Perl programming language that
counts from 0 to some very large number. You cannot do anything useful
in your terminal until the program stops, which unfortunately, is a long
time from now. Fortunately, we can break out of the program with ^C. Do
that now.</p>

<p>But what if you just wanted to pause the program and restart it again?
You can do that with ^Z. So let&#39;s go back and execute that command again
(use the up arrow) and this time send it a sleep signal.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">perl -e &#39;while(1){print $i++, chr(10)}&#39;
</code></pre></div>
<p>Now hit ^Z. To get it to pick up where it left off, use the <code>fg</code> command
to put the process into the <strong>foreground</strong>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">fg
</code></pre></div>
<p>Now go look at <code>top</code>. You should see a perl process using a lot of CPU.
Every process (program) on your computer has a process ID (PID). If you
know the PID of a process, you can take control of it (assuming it is
yours). My perl process has PID 6000. On yours it is probably different.
You can view all your processes with the <code>ps</code> command. In the following
command, replace <code>ian</code> with your user name: <code>bios180student</code>.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ps -u ian
</code></pre></div>
<p>However you attain the PID of your offending process, you can <code>kill</code> it.
Replace <code>6000</code> with your PID.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">kill 6000
</code></pre></div>
<p>You can put processes into the <strong>background</strong>. This will mean the
terminal no longer controls them. You can&#39;t ^C to interrupt such a
process, but you can use the <code>kill</code> command. Add <code>&amp;</code> to the end of a
command line to put it into the background or use the <code>bg</code> command to
put a paused process into the background. You shouldn&#39;t need to do these
things in this class, but we include this info for completeness.</p>

<h2>Unix Reference</h2>

<p>| Token  | Function
|:--------|:-------------------------------------|
| .       | your current directory (see pwd)
| ..      | your parent directory
| ~       | your home directory (also $HOME)
| ^c      | send interrupt signal to current process
| ^d      | send end-of-file character
| ^z      | send sleep signal current process: see bg and fg
| tab     | tab-complete names
| *       | wildcard - matches everything
| &amp;       | send command to background
| |      | pipe output from one command to another
| &gt;       | redirect output to file</p>

<p>| Command   | Example       | Intent                        |
|:----------|:--------------|:------------------------------|
| <code>bg</code>      | <code>bg</code>          | send a sleeping process to background
| <code>cat</code>     | <code>cat &gt; f</code>     | create file f and wait for keyboard (see ^d)
|           | <code>cat f</code>       | stream contents of file f to STDOUT
|           | <code>cat a b &gt; c</code> | concatenate files a and b into c
| <code>cd</code>      | <code>cd d</code>        | change to relative directory d
|           | <code>cd ..</code>       | go up one directory
|           | <code>cd /d</code>       | change to absolute directory d
| <code>chmod</code>   | <code>chmod 644 f</code> | change file permissions 
|           | <code>chmod u+x f</code> | change file permissions
| <code>cp</code>      | <code>cp f1 f2</code>    | make a copy of file f1 called f2
| <code>cut</code>     | <code>cut -f 5 ff</code> | print column 5 from file ff
| <code>date</code>    | <code>date</code>        | print the current date
| <code>df</code>      | <code>df -h .</code>     | display free space on file system
| <code>du</code>      | <code>du -h ~</code>     | display the sizes of your files
| <code>fg</code>      | <code>fg</code>          | send sleeping process to foreground
| <code>grep</code>    | <code>grep p f</code>    | print lines with the letter p in file f
| <code>gzip</code>    | <code>gzip f</code>      | compress file f
| <code>gunzip</code>  | <code>gunzip f.gz</code> | uncompress file f.gz
| <code>head</code>    | <code>head f</code>      | display the first 10 lines of file f
|           | <code>head -2 f</code>   | display the first 2 lines of file f
| <code>history</code> | <code>history</code>     | display the recent commands you typed
| <code>kill</code>    | <code>kill 1023</code>   | kill process with id 1023
| <code>less</code>    | <code>less f</code>      | page through a file
| <code>ln</code>      | <code>ln -s f1 f2</code> | make f2 an alias of f1
| <code>ls</code>      | <code>ls</code>          | list current directory
|           | <code>ls -l</code>       | list with file details
|           | <code>ls -la</code>      | also show invisible files
|           | <code>ls -lta</code>     | sort by time instead of name
|           | <code>ls -ltaF</code>    | also show file type symbols
| <code>man</code>     | <code>man ls</code>      | read the manual page on ls command
| <code>mkdir</code>   | <code>mkdir d</code>     | make a directory named d
| <code>more</code>    | <code>more f</code>      | page through file f (see less)
| <code>mv</code>      | <code>mv foo bar</code>  | rename file foo as bar
|           | <code>mv foo ..</code>   | move file foo to parent directory
| <code>nano</code>    | <code>nano</code>        | use the nano text file editor
| <code>passwd</code>  | <code>passwd</code>      | change your password
| <code>pwd</code>     | <code>pwd</code>         | print working directory
| <code>ps</code>      | <code>ps</code>          | show current processes
|           | <code>ps -u ian</code>   | show processes user ian is running
| <code>rm</code>      | <code>rm f1 f2</code>    | remove files f1 and f2
|           | <code>rm -r d</code>     | remove directory d and all files beneath
|           | <code>rm -rf /</code>    | destroy your computer
| <code>rmdir</code>   | <code>rmdir d</code>     | remove directory d
| <code>sort</code>    | <code>sort f</code>      | sort file f alphabetically by first column
|           | <code>sort -n f</code>   | sort file f numerically by first column
|           | <code>sort -k 2 f</code> | sort file f alphabetically by column 2
| <code>ssh</code>     | <code>ssh hal</code>     | remotely log into machine hal
| <code>tail</code>    | <code>tail f</code>      | display the last 10 lines of file f
|           | <code>tail -f f</code>   | as above and keep displaying if file is open
| <code>tar</code>     | <code>tar -cf ...</code> | create a compressed tar-ball (-z to compress)
|           | <code>tar -xf ...</code> | decompress a tar-ball (-z if compressed)
| <code>time</code>    | <code>time ...</code>    | determine how much time a process takes
| <code>top</code>     | <code>top</code>         | display processes running on your system
| <code>touch</code>   | <code>touch f</code>     | update file f modification time (create if needed)
| <code>wc</code>      | <code>wc f</code>        | count the lines, words, and characters in file f</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                <b>Resouces<br />
                <a href = "http://daringfireball.net/projects/markdown/syntax">Markdown Syntax Guide</a><br />
                <a href = "/docs/ianCheatSheet.html"> Ian's Unix Cheat Sheet</a><br />
                <a href="/docs/virtualMachine.html">Installing and Using Virtual Machine</a>
              </p>
            </div>

            <div class="contact">
              <p>
                
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
